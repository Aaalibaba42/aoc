s â† â€¢Import "../bqn-libs/strings.bqn"

lines â† â€¢FLines "d07.input"

# Binary Logic
And â† 16â€¢bit._andâ—‹â¥Š
Or â† 16â€¢bit._orâ—‹â¥Š
Not â† 16â€¢bit._notâ¥Š
mod â† 2â‹†16
LShift â† modâŠ¸|âŠ£Ã—2âŠ¸â‹†
RShift â† âŒŠâŠ£Ã·2âŠ¸â‹†

# Helper functions/modifiers
IsNum â† âˆ§Â´('0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9')
_dispatch_ â† {ğ•—âŠ¸âŠ‘âŸœğ•˜ {ğ•ğ•©} âŠ¢}
_apply â† {F _ğ•£ wâ€¿x: w F x}

# Constants
opNames â† "AND"â€¿"OR"â€¿"LSHIFT"â€¿"RSHIFT"
opFuncs â† âŸ¨And, Or, LShift, RShiftâŸ©
OpLookup â† (âŠ‘opNamesâŠ¸âŠâˆ˜<)âŠ¸âŠ‘âŸœopFuncs

# Solution
Solution â† {
  # Computed Wire Values
  wires â† âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©

  _exprRef â† {ğ”½ âŠ‘ğ•©}
  _exprNot â† {Not ğ”½ 1âŠ‘ğ•©}
  _exprBinOp â† {(OpLookup 1âŠ‘ğ•©)_apply (ğ”½ âŠ‘ğ•©)â€¿(ğ”½ 2âŠ‘ğ•©)}

  instructions â† (Â¯1âŠ¸âŠ‘Â¨ â€¢HashMap Â¯2âŠ¸â†“Â¨) ' 'âŠ¸s.SplitÂ¨ lines
  Signal â† {
    exprHandlers â† âŸ¨ ğ•Š _exprRef â‹„ ğ•Š _exprNot â‹„ ğ•Š _exprBinOp âŸ©
    RunExpr â† (-âŸœ1âˆ˜â‰ ) _dispatch_ exprHandlers
    ComputeWire â† {
      val â† RunExpr instructions.Get ğ•©
      ğ•© wires.Set val
      val
    }
    signalConds â† âŸ¨ IsNum â‹„ wires.Has â‹„ 1Ë™ âŸ©
    signalActions â† âŸ¨ â€¢ParseFloat â‹„ wires.Get â‹„ ComputeWire âŸ©
    ((âŠ‘âŠâŸœ1âˆ˜{signalConds{ğ•ğ•©}Â¨<ğ•©}) _dispatch_ signalActions) ğ•©
  }

  âŠ‘Signal ğ•©
}

â€¢Show Solution "a"
