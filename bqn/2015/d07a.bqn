s â† â€¢Import "../bqn-libs/strings.bqn"

lines â† â€¢FLines "d07.input"

# Binary Logic
And â† 16â€¢bit._andâŒ¾â‹ˆ
Or â† 16â€¢bit._orâŒ¾â‹ˆ
Not â† 16â€¢bit._notâŒ¾â‹ˆ
mod â† 2â‹†16
LShift â† modâŠ¸|âŠ£Ã—2âŠ¸â‹†
RShift â† âŒŠâŠ£Ã·2âŠ¸â‹†

# Helper functions/modifiers
IsNum â† âˆ§Â´'0'âŠ¸â‰¤âˆ§â‰¤âŸœ'9'
# Constants
opNames â† "AND"â€¿"OR"â€¿"LSHIFT"â€¿"RSHIFT"
opFuncs â† âŸ¨And, Or, LShift, RShiftâŸ©
OpLookup â† (âŠ‘opNamesâŠ¸âŠâˆ˜<)âŠ¸âŠ‘âŸœopFuncs

# Solution
Solution â† {
  # Computed Wire Values
  wires â† âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©

  _exprRef â† { ğ”½ âŠ‘ğ•© }
  _exprNot â† { Not ğ”½ 1âŠ‘ğ•© }
  _exprBinOp â† { ğ”½_ğ•£ lâ€¿oâ€¿r: l (OpLookup o)â—‹ğ”½ r }

  instructions â† (Â¯1âŠ¸âŠ‘Â¨ â€¢HashMap Â¯2âŠ¸â†“Â¨) ' 'âŠ¸s.SplitÂ¨ lines
  Signal â† {
    exprHandlers â† âŸ¨ ğ•Š _exprRef â‹„ ğ•Š _exprNot â‹„ ğ•Š _exprBinOp âŸ©
    RunExpr â† (-âŸœ1âˆ˜â‰ )â—¶exprHandlers
    ComputeWire â† {
      val â† RunExpr instructions.Get ğ•©
      ğ•© wires.Set val
      val
    }
    signalConds â† âŸ¨ IsNum â‹„ wires.Has â‹„ 1Ë™ âŸ©
    signalActions â† âŸ¨ â€¢ParseFloat â‹„ wires.Get â‹„ ComputeWire âŸ©
    (âŠ‘âŠâŸœ1âˆ˜{signalConds{ğ•ğ•©}Â¨<ğ•©})â—¶signalActions ğ•©
  }

  Signal ğ•©
}

â€¢Show Solution "a"
